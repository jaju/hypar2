#pragma once
#include "localdefs.h"
#include "hash.hpp"
#include "hashmap.hpp"
#include "tag.hpp"
#include "tree.hpp"

BEGIN_NAMESPACE(hy);

typedef HashMap <const _char *, const _char *, strcasehash, eqcase> PropertyMap;

/**
 * The DOM element
 *
 * The tree is made up of DOMNode nodes. This tree is generated by the
 * XML::parse call. One can derive from this basic DOMNode class, and
 * do all analysis stuff in the derived class. DOMNode provides only
 * basic functionality.
 */

class DOMNode : public TreeNode
{
    public:
        typedef void (*CallBack) (DOMNode *, void *);
        typedef enum
        {
            END = -1,
            ELEMENT,
            TEXT,
            COMMENT
        }
        NodeType;

    public:
        NodeType &type() { return m_type; }
        void setType(NodeType type) { m_type = type; }
        const char *name() const { return m_pName; }
        void setName(const char *name) { m_pName = name; }
        const char *content() const { return m_pContent; }
        bool &selfClosing() { return m_bSelfClosing; }

    public: // convenience
        DOMNode *&parent() { return (DOMNode *&) TreeNode::parent(); }
        DOMNode *&child() { return (DOMNode *&) TreeNode::child(); }
        DOMNode *&previous() { return (DOMNode *&) TreeNode::previous(); }
        DOMNode *&next() { return (DOMNode *&) TreeNode::next(); }
        DOMNode *&last() { return (DOMNode *&) TreeNode::last(); }

    private:
        void reset ();

    public:
        DOMNode () {}
        DOMNode (NodeType nodeType, const _char *pStr);

        virtual DOMNode *clone () const;
        virtual DOMNode *clone (NodeType nodeType, const _char *pName = 0) const;

    public:
        virtual ~DOMNode ();

    public:
    public:
        int addProperty (pair <const _char *, const _char *> &p);
        int addProperty (const _char *pName, const _char *pValue);
        int copyAttributes (Tag *tag);
        const _char *findProperty (const _char *pName) const;
        void toString (_string &targetString, bool bChildOnly = false) const;
        _string toString(bool bChildOnly = false) const;
        void toText (_string &targetString, bool bChildOnly = false) const;
        void recursiveCb (CallBack);

    public:
        int collectNodesByName (const _char *pName, list<DOMNode *> *pNodeList,
                bool siblings = false);
        int collectNodesByAttrVal (const _char *pAttr, const _char *pVal,
                list<DOMNode *> *pNodeList, bool siblings = false);

        int collectChildrenByType (NodeType type, list<DOMNode *> *pNodeList);
        int collectChildrenByName (const _char *pName,
                list<DOMNode *> *pNodeList);

    public:
        DOMNode *findFirstChild (const _char *pName);
        DOMNode *findFirstChild (NodeType type);
        DOMNode *findNext (const _char *pName, bool bConsiderThis = false);
        DOMNode *findNext (NodeType type, bool bConsiderThis = false);

    public:
        inline bool equals (const _char *pName) const
        {
            if (m_type == ELEMENT)
                return (_strcasecmp (pName, m_pName) ? false : true);
            return false;
        }

    private:
        PropertyMap *m_pPropertyMap;

    protected:
        NodeType m_type;
        const _char *m_pName, *m_pContent;
        bool m_bSelfClosing;
        int m_iLevel, m_iHorLevel;

};
END_NAMESPACE(hy);
