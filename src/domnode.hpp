#pragma once
#include "localdefs.h"
#include "hash.hpp"
#include "hashmap.hpp"
#include "tag.hpp"
#include "tree.hpp"

BEGIN_NAMESPACE(hy);

typedef HashMap <const _char *, const _char *, strcasehash, eqcase> PropertyMap;
class DOMNode;
typedef list <DOMNode * > NodeList;

/**
 * The DOM element
 *
 * The tree is made up of DOMData nodes. This tree is generated by the
 * XML::parse call. One can derive from this basic DOMData class, and
 * do all analysis stuff in the derived class. DOMData provides only
 * basic functionality.
 */

class DOMData
{
    public:
        typedef void (*CallBack) (DOMData *, void *);
        typedef enum
        {
            END = -1,
            ELEMENT,
            TEXT,
            COMMENT
        }
        NodeType;

    public:
        const NodeType type() { return m_type; }
        void setType(NodeType type) { m_type = type; }
        const char *name() const { return m_pName; }
        void setName(const char *name) { m_pName = name; }
        const char *content() const { return m_pContent; }
        bool selfClosing() { return m_bSelfClosing; }
        void setSelfClosing(bool s) { m_bSelfClosing = s; }

    protected:
        void reset ();

    public:
        DOMData ();
        DOMData (NodeType nodeType, const _char *pStr);
        virtual ~DOMData ();

    public:
        int addProperty (pair <const _char *, const _char *> &p);
        int addProperty (const _char *pName, const _char *pValue);
        int copyAttributes (Tag *tag);
        const _char *findProperty (const _char *pName) const;

    public:
        inline bool equals (const _char *pName) const
        {
            if (m_type == ELEMENT)
                return (_strcasecmp (pName, m_pName) ? false : true);
            return false;
        }

    protected:
        void initData(NodeType nodeType, const _char *pStr);
        PropertyMap *m_pPropertyMap;
        NodeType m_type;
        const _char *m_pName, *m_pContent;
        bool m_bSelfClosing;

};

class DOMNode : public TreeNode<DOMData> {
    public:
        DOMNode () {}
        DOMNode(NodeType nodeType, const _char *pStr) {
            initData(nodeType, pStr);
        }

    public:
        DOMNode *findFirstChild (const _char *pName);
        DOMNode *findFirstChild (NodeType type);
        DOMNode *findNext (const _char *pName, bool bConsiderThis = false);
        DOMNode *findNext (NodeType type, bool bConsiderThis = false);
        void recursiveCb (CallBack);

    public:
        int collectNodesByName (const _char *pName, NodeList *pNodeList,
                bool siblings = false);
        int collectNodesByAttrVal (const _char *pAttr, const _char *pVal,
                NodeList *pNodeList, bool siblings = false);

        int collectChildrenByType (NodeType type, NodeList *pNodeList);
        int collectChildrenByName (const _char *pName,
                NodeList *pNodeList);
        void toString (_string &targetString, bool bChildOnly = false);
        _string toString(bool bChildOnly = false);
        void toText (_string &targetString, bool bChildOnly = false);
        virtual DOMNode *clone () const;
        virtual DOMNode *clone (NodeType nodeType, const _char *pName = 0) const;

    public: // convenience
        DOMNode *&child() { return (DOMNode *&) _child; }
        void setChild(DOMNode *n) { _child = n; }
        DOMNode *&parent() { return (DOMNode *&) _parent; }
        void setParent(DOMNode *n) { _parent = n; }
        DOMNode *&next() { return (DOMNode *&) _next; }
        void setNext(DOMNode *n) { _next = n; }
        DOMNode *&last() { return (DOMNode *&) _last; }
        void setLast(DOMNode *n) { _last = n; }
        DOMNode *&prev() { return (DOMNode *&) _prev; }
        void setPrev(DOMNode *n) { _prev = n; }


    protected:
        void reset ();
};

END_NAMESPACE(hy);
