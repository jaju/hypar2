#pragma once
#include "localdefs.h"
#include "hash.hpp"
#include "hashmap.hpp"
#include "tag.hpp"
#include "tree.hpp"

BEGIN_NAMESPACE(hy);

typedef HashMap <const _char *, const _char *, strcasehash, eqcase> PropertyMap;

/**
 * The DOM element
 *
 * The tree is made up of DOMData nodes. This tree is generated by the
 * XML::parse call. One can derive from this basic DOMData class, and
 * do all analysis stuff in the derived class. DOMData provides only
 * basic functionality.
 */

class DOMData
{
    public:
    typedef enum
    {
        END = -1,
        ELEMENT,
        TEXT,
        COMMENT
    }
    NodeType;

    public:
    NodeType type()                const { return m_type; }
    void setType(NodeType type)    { m_type = type; }

    const char *name()             const { return m_pName; }
    void setName(const char *name) { m_pName = name; }

    bool selfClosing()             const { return m_bSelfClosing; }
    void setSelfClosing(bool s)    { m_bSelfClosing = s; }

    const char *content()            const { return m_pContent; }
    const PropertyMap *propertyMap() const { return m_pPropertyMap; }

    public:
    DOMData ();
    DOMData (const DOMData &other);
    void initType(NodeType nodeType, const _char *pStr);
    virtual ~DOMData ();

    public:
    const _char *getProperty (const _char *pName) const;
    int setProperty (const _char *pName, const _char *pValue);
    int setProperty (std::pair<const _char *, const _char *> p);
    int copyAttributes (Tag *tag);

    protected:
    PropertyMap *m_pPropertyMap;
    NodeType m_type;
    const _char *m_pName, *m_pContent;
    bool m_bSelfClosing;

    protected:
    void reset ();

    private:
    static const char* const defaultName;
};

typedef TreeNode<DOMData> DOMNode;
typedef std::list <DOMNode *> NodeList;

void toString (DOMNode *node, _string &targetString, bool bChildOnly = false);
_string toString(DOMNode *node, bool bChildOnly = false);
void toText (DOMNode *node, _string &targetString, bool bChildOnly = false);

END_NAMESPACE(hy);
